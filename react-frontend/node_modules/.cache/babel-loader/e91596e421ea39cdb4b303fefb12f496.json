{"ast":null,"code":"/* eslint no-console: 0 */\n'use strict';\n\nconst urllib = require('url');\n\nconst util = require('util');\n\nconst fs = require('fs');\n\nconst fetch = require('../fetch');\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\n\n\nmodule.exports.parseConnectionUrl = str => {\n  str = str || '';\n  let options = {};\n  [urllib.parse(str, true)].forEach(url => {\n    let auth;\n\n    switch (url.protocol) {\n      case 'smtp:':\n        options.secure = false;\n        break;\n\n      case 'smtps:':\n        options.secure = true;\n        break;\n\n      case 'direct:':\n        options.direct = true;\n        break;\n    }\n\n    if (!isNaN(url.port) && Number(url.port)) {\n      options.port = Number(url.port);\n    }\n\n    if (url.hostname) {\n      options.host = url.hostname;\n    }\n\n    if (url.auth) {\n      auth = url.auth.split(':');\n\n      if (!options.auth) {\n        options.auth = {};\n      }\n\n      options.auth.user = auth.shift();\n      options.auth.pass = auth.join(':');\n    }\n\n    Object.keys(url.query || {}).forEach(key => {\n      let obj = options;\n      let lKey = key;\n      let value = url.query[key];\n\n      if (!isNaN(value)) {\n        value = Number(value);\n      }\n\n      switch (value) {\n        case 'true':\n          value = true;\n          break;\n\n        case 'false':\n          value = false;\n          break;\n      } // tls is nested object\n\n\n      if (key.indexOf('tls.') === 0) {\n        lKey = key.substr(4);\n\n        if (!options.tls) {\n          options.tls = {};\n        }\n\n        obj = options.tls;\n      } else if (key.indexOf('.') >= 0) {\n        // ignore nested properties besides tls\n        return;\n      }\n\n      if (!(lKey in obj)) {\n        obj[lKey] = value;\n      }\n    });\n  });\n  return options;\n};\n\nmodule.exports._logFunc = function (logger, level, defaults, data, message) {\n  let entry = {};\n  Object.keys(defaults || {}).forEach(key => {\n    if (key !== 'level') {\n      entry[key] = defaults[key];\n    }\n  });\n  Object.keys(data || {}).forEach(key => {\n    if (key !== 'level') {\n      entry[key] = data[key];\n    }\n  });\n\n  for (var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n    args[_key - 5] = arguments[_key];\n  }\n\n  logger[level](entry, message, ...args);\n};\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\n\n\nmodule.exports.getLogger = (options, defaults) => {\n  options = options || {};\n  let response = {};\n  let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n  if (!options.logger) {\n    // use vanity logger\n    levels.forEach(level => {\n      response[level] = () => false;\n    });\n    return response;\n  }\n\n  let logger = options.logger;\n\n  if (options.logger === true) {\n    // create console logger\n    logger = createDefaultLogger(levels);\n  }\n\n  levels.forEach(level => {\n    response[level] = function (data, message) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      module.exports._logFunc(logger, level, defaults, data, message, ...args);\n    };\n  });\n  return response;\n};\n/**\n * Wrapper for creating a callback than either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\n\n\nmodule.exports.callbackPromise = (resolve, reject) => function () {\n  let args = Array.from(arguments);\n  let err = args.shift();\n\n  if (err) {\n    reject(err);\n  } else {\n    resolve(...args);\n  }\n};\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\n\n\nmodule.exports.resolveContent = (data, key, callback) => {\n  let promise;\n\n  if (!callback && typeof Promise === 'function') {\n    promise = new Promise((resolve, reject) => {\n      callback = module.exports.callbackPromise(resolve, reject);\n    });\n  }\n\n  let content = data && data[key] && data[key].content || data[key];\n  let contentStream;\n  let encoding = (typeof data[key] === 'object' && data[key].encoding || 'utf8').toString().toLowerCase().replace(/[-_\\s]/g, '');\n\n  if (!content) {\n    return callback(null, content);\n  }\n\n  if (typeof content === 'object') {\n    if (typeof content.pipe === 'function') {\n      return resolveStream(content, (err, value) => {\n        if (err) {\n          return callback(err);\n        } // we can't stream twice the same content, so we need\n        // to replace the stream object with the streaming result\n\n\n        data[key] = value;\n        callback(null, value);\n      });\n    } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n      contentStream = fetch(content.path || content.href);\n      return resolveStream(contentStream, callback);\n    } else if (/^data:/i.test(content.path || content.href)) {\n      let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n\n      if (!parts) {\n        return callback(null, Buffer.from(0));\n      }\n\n      return callback(null, /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2])));\n    } else if (content.path) {\n      return resolveStream(fs.createReadStream(content.path), callback);\n    }\n  }\n\n  if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n    content = Buffer.from(data[key].content, encoding);\n  } // default action, return as is\n\n\n  setImmediate(() => callback(null, content));\n  return promise;\n};\n/**\n * Copies properties from source objects to target objects\n */\n\n\nmodule.exports.assign = function\n  /* target, ... sources */\n() {\n  let args = Array.from(arguments);\n  let target = args.shift() || {};\n  args.forEach(source => {\n    Object.keys(source || {}).forEach(key => {\n      if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n        // tls and auth are special keys that need to be enumerated separately\n        // other objects are passed as is\n        if (!target[key]) {\n          // ensure that target has this key\n          target[key] = {};\n        }\n\n        Object.keys(source[key]).forEach(subKey => {\n          target[key][subKey] = source[key][subKey];\n        });\n      } else {\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n};\n\nmodule.exports.encodeXText = str => {\n  // ! 0x21\n  // + 0x2B\n  // = 0x3D\n  // ~ 0x7E\n  if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n    return str;\n  }\n\n  let buf = Buffer.from(str);\n  let result = '';\n\n  for (let i = 0, len = buf.length; i < len; i++) {\n    let c = buf[i];\n\n    if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n      result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n    } else {\n      result += String.fromCharCode(c);\n    }\n  }\n\n  return result;\n};\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\n\n\nfunction resolveStream(stream, callback) {\n  let responded = false;\n  let chunks = [];\n  let chunklen = 0;\n  stream.on('error', err => {\n    if (responded) {\n      return;\n    }\n\n    responded = true;\n    callback(err);\n  });\n  stream.on('readable', () => {\n    let chunk;\n\n    while ((chunk = stream.read()) !== null) {\n      chunks.push(chunk);\n      chunklen += chunk.length;\n    }\n  });\n  stream.on('end', () => {\n    if (responded) {\n      return;\n    }\n\n    responded = true;\n    let value;\n\n    try {\n      value = Buffer.concat(chunks, chunklen);\n    } catch (E) {\n      return callback(E);\n    }\n\n    callback(null, value);\n  });\n}\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\n\n\nfunction createDefaultLogger(levels) {\n  let levelMaxLen = 0;\n  let levelNames = new Map();\n  levels.forEach(level => {\n    if (level.length > levelMaxLen) {\n      levelMaxLen = level.length;\n    }\n  });\n  levels.forEach(level => {\n    let levelName = level.toUpperCase();\n\n    if (levelName.length < levelMaxLen) {\n      levelName += ' '.repeat(levelMaxLen - levelName.length);\n    }\n\n    levelNames.set(level, levelName);\n  });\n\n  let print = function (level, entry, message) {\n    let prefix = '';\n\n    if (entry) {\n      if (entry.tnx === 'server') {\n        prefix = 'S: ';\n      } else if (entry.tnx === 'client') {\n        prefix = 'C: ';\n      }\n\n      if (entry.sid) {\n        prefix = '[' + entry.sid + '] ' + prefix;\n      }\n\n      if (entry.cid) {\n        prefix = '[#' + entry.cid + '] ' + prefix;\n      }\n    }\n\n    for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n      args[_key3 - 3] = arguments[_key3];\n    }\n\n    message = util.format(message, ...args);\n    message.split(/\\r?\\n/).forEach(line => {\n      console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);\n    });\n  };\n\n  let logger = {};\n  levels.forEach(level => {\n    logger[level] = print.bind(null, level);\n  });\n  return logger;\n}","map":{"version":3,"names":["urllib","require","util","fs","fetch","module","exports","parseConnectionUrl","str","options","parse","forEach","url","auth","protocol","secure","direct","isNaN","port","Number","hostname","host","split","user","shift","pass","join","Object","keys","query","key","obj","lKey","value","indexOf","substr","tls","_logFunc","logger","level","defaults","data","message","entry","args","getLogger","response","levels","createDefaultLogger","callbackPromise","resolve","reject","Array","from","arguments","err","resolveContent","callback","promise","Promise","content","contentStream","encoding","toString","toLowerCase","replace","pipe","resolveStream","test","path","href","parts","match","Buffer","decodeURIComponent","createReadStream","includes","setImmediate","assign","target","source","subKey","encodeXText","buf","result","i","len","length","c","toUpperCase","String","fromCharCode","stream","responded","chunks","chunklen","on","chunk","read","push","concat","E","levelMaxLen","levelNames","Map","levelName","repeat","set","print","prefix","tnx","sid","cid","format","line","console","log","Date","toISOString","get","bind"],"sources":["/home/bijen/Desktop/LaravelReact/react-frontend/node_modules/nodemailer/lib/shared/index.js"],"sourcesContent":["/* eslint no-console: 0 */\n\n'use strict';\n\nconst urllib = require('url');\nconst util = require('util');\nconst fs = require('fs');\nconst fetch = require('../fetch');\n\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\nmodule.exports.parseConnectionUrl = str => {\n    str = str || '';\n    let options = {};\n\n    [urllib.parse(str, true)].forEach(url => {\n        let auth;\n\n        switch (url.protocol) {\n            case 'smtp:':\n                options.secure = false;\n                break;\n            case 'smtps:':\n                options.secure = true;\n                break;\n            case 'direct:':\n                options.direct = true;\n                break;\n        }\n\n        if (!isNaN(url.port) && Number(url.port)) {\n            options.port = Number(url.port);\n        }\n\n        if (url.hostname) {\n            options.host = url.hostname;\n        }\n\n        if (url.auth) {\n            auth = url.auth.split(':');\n\n            if (!options.auth) {\n                options.auth = {};\n            }\n\n            options.auth.user = auth.shift();\n            options.auth.pass = auth.join(':');\n        }\n\n        Object.keys(url.query || {}).forEach(key => {\n            let obj = options;\n            let lKey = key;\n            let value = url.query[key];\n\n            if (!isNaN(value)) {\n                value = Number(value);\n            }\n\n            switch (value) {\n                case 'true':\n                    value = true;\n                    break;\n                case 'false':\n                    value = false;\n                    break;\n            }\n\n            // tls is nested object\n            if (key.indexOf('tls.') === 0) {\n                lKey = key.substr(4);\n                if (!options.tls) {\n                    options.tls = {};\n                }\n                obj = options.tls;\n            } else if (key.indexOf('.') >= 0) {\n                // ignore nested properties besides tls\n                return;\n            }\n\n            if (!(lKey in obj)) {\n                obj[lKey] = value;\n            }\n        });\n    });\n\n    return options;\n};\n\nmodule.exports._logFunc = (logger, level, defaults, data, message, ...args) => {\n    let entry = {};\n\n    Object.keys(defaults || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = defaults[key];\n        }\n    });\n\n    Object.keys(data || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = data[key];\n        }\n    });\n\n    logger[level](entry, message, ...args);\n};\n\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\nmodule.exports.getLogger = (options, defaults) => {\n    options = options || {};\n\n    let response = {};\n    let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n    if (!options.logger) {\n        // use vanity logger\n        levels.forEach(level => {\n            response[level] = () => false;\n        });\n        return response;\n    }\n\n    let logger = options.logger;\n\n    if (options.logger === true) {\n        // create console logger\n        logger = createDefaultLogger(levels);\n    }\n\n    levels.forEach(level => {\n        response[level] = (data, message, ...args) => {\n            module.exports._logFunc(logger, level, defaults, data, message, ...args);\n        };\n    });\n\n    return response;\n};\n\n/**\n * Wrapper for creating a callback than either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\nmodule.exports.callbackPromise = (resolve, reject) =>\n    function() {\n        let args = Array.from(arguments);\n        let err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve(...args);\n        }\n    };\n\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\nmodule.exports.resolveContent = (data, key, callback) => {\n    let promise;\n\n    if (!callback && typeof Promise === 'function') {\n        promise = new Promise((resolve, reject) => {\n            callback = module.exports.callbackPromise(resolve, reject);\n        });\n    }\n\n    let content = (data && data[key] && data[key].content) || data[key];\n    let contentStream;\n    let encoding = ((typeof data[key] === 'object' && data[key].encoding) || 'utf8')\n        .toString()\n        .toLowerCase()\n        .replace(/[-_\\s]/g, '');\n\n    if (!content) {\n        return callback(null, content);\n    }\n\n    if (typeof content === 'object') {\n        if (typeof content.pipe === 'function') {\n            return resolveStream(content, (err, value) => {\n                if (err) {\n                    return callback(err);\n                }\n                // we can't stream twice the same content, so we need\n                // to replace the stream object with the streaming result\n                data[key] = value;\n                callback(null, value);\n            });\n        } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n            contentStream = fetch(content.path || content.href);\n            return resolveStream(contentStream, callback);\n        } else if (/^data:/i.test(content.path || content.href)) {\n            let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n            if (!parts) {\n                return callback(null, Buffer.from(0));\n            }\n            return callback(null, /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2])));\n        } else if (content.path) {\n            return resolveStream(fs.createReadStream(content.path), callback);\n        }\n    }\n\n    if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n        content = Buffer.from(data[key].content, encoding);\n    }\n\n    // default action, return as is\n    setImmediate(() => callback(null, content));\n\n    return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nmodule.exports.assign = function(/* target, ... sources */) {\n    let args = Array.from(arguments);\n    let target = args.shift() || {};\n\n    args.forEach(source => {\n        Object.keys(source || {}).forEach(key => {\n            if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n                // tls and auth are special keys that need to be enumerated separately\n                // other objects are passed as is\n                if (!target[key]) {\n                    // ensure that target has this key\n                    target[key] = {};\n                }\n                Object.keys(source[key]).forEach(subKey => {\n                    target[key][subKey] = source[key][subKey];\n                });\n            } else {\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n};\n\nmodule.exports.encodeXText = str => {\n    // ! 0x21\n    // + 0x2B\n    // = 0x3D\n    // ~ 0x7E\n    if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n        return str;\n    }\n    let buf = Buffer.from(str);\n    let result = '';\n    for (let i = 0, len = buf.length; i < len; i++) {\n        let c = buf[i];\n        if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n            result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n        } else {\n            result += String.fromCharCode(c);\n        }\n    }\n    return result;\n};\n\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\nfunction resolveStream(stream, callback) {\n    let responded = false;\n    let chunks = [];\n    let chunklen = 0;\n\n    stream.on('error', err => {\n        if (responded) {\n            return;\n        }\n\n        responded = true;\n        callback(err);\n    });\n\n    stream.on('readable', () => {\n        let chunk;\n        while ((chunk = stream.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    stream.on('end', () => {\n        if (responded) {\n            return;\n        }\n        responded = true;\n\n        let value;\n\n        try {\n            value = Buffer.concat(chunks, chunklen);\n        } catch (E) {\n            return callback(E);\n        }\n        callback(null, value);\n    });\n}\n\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\nfunction createDefaultLogger(levels) {\n    let levelMaxLen = 0;\n    let levelNames = new Map();\n    levels.forEach(level => {\n        if (level.length > levelMaxLen) {\n            levelMaxLen = level.length;\n        }\n    });\n\n    levels.forEach(level => {\n        let levelName = level.toUpperCase();\n        if (levelName.length < levelMaxLen) {\n            levelName += ' '.repeat(levelMaxLen - levelName.length);\n        }\n        levelNames.set(level, levelName);\n    });\n\n    let print = (level, entry, message, ...args) => {\n        let prefix = '';\n        if (entry) {\n            if (entry.tnx === 'server') {\n                prefix = 'S: ';\n            } else if (entry.tnx === 'client') {\n                prefix = 'C: ';\n            }\n\n            if (entry.sid) {\n                prefix = '[' + entry.sid + '] ' + prefix;\n            }\n\n            if (entry.cid) {\n                prefix = '[#' + entry.cid + '] ' + prefix;\n            }\n        }\n\n        message = util.format(message, ...args);\n        message.split(/\\r?\\n/).forEach(line => {\n            console.log(\n                '[%s] %s %s',\n                new Date()\n                    .toISOString()\n                    .substr(0, 19)\n                    .replace(/T/, ' '),\n                levelNames.get(level),\n                prefix + line\n            );\n        });\n    };\n\n    let logger = {};\n    levels.forEach(level => {\n        logger[level] = print.bind(null, level);\n    });\n\n    return logger;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}